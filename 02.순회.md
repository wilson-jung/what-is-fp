```js
// es5
var list = [1, 2, 3]
for (var i = 0; i < list.length; i++) {
  console.log(list[i])
}

// es6
const list = [1, 2, 3]
for (const a of list) {
  console.log(a)
}
```
### Array
```js
const arr = [1,2,3]
for (const a of arr) console.log(a)
```

### Set
```js
const set = new Set([1,2,3])
for (const a of set) console.log(a)
```

### Map
```js
const map = new Map([['a', 1], ['b', 2], ['c', 3]])
for (const a of map) console.log(a)
```

## Iterable/Iterator Protocol
- Iterable: Iterator를 리턴하는 [Symbol.iterator]() 를 가진 값
- Iterator: { value, done } 객체를 리턴하는 next() 를 가진 값
- Iterable/Iterator Protocol: Iterable을 for...of, 전개 연산자 등과 함께 동작하도록한 규약 


### Array 다시 보기
```js
const arr = [1,2,3]
const iter = arr[Symbol.iterator]()
iter.next()
for (const a of iter) console.log(a)
```

### 사용자 정의 Iterable
```js
const iterable = {
  [Symbol.iterator]() {
    let i = 3
    return {
      next() {
        return i === 0 ? { done: true } : { value: i--, done: false }
      }
    }
  }
}
const iterator = iterable[Symbol.iterator]()
// console.log(iterator.next())
// console.log(iterator.next())
// console.log(iterator.next())
// console.log(iterator.next())

for (const a of iterator) console.log(a)
```

잘 만들어진 Iterable은 순회를 중단 재개 할 수 있다.
```js
const arr = [1,2,3]
let iter = arr[Symbol.iterator]()
iter.next()
console.log(iter[Symbol.iterator]() === iter) // well formed iterator
for (const a of iter) console.log(a)
```

### 사용자 정의 이터러블을 발전시켜보자
```js
const iterable = {
  [Symbol.iterator]() {
    let i = 3
    return {
      next() {
        return i === 0 ? { done: true } : { value: i--, done: false }
      },
      [Symbol.iterator]() {
        return this
      }
    }
  }
}
const iterator = iterable[Symbol.iterator]()
iterator.next()

for (const a of iterator) console.log(a)
```

## 전개 연산자(Spread Operator)
- iterable protocal을 따르는 값들을 펼치는 것
