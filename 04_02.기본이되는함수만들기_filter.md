### filter: 거르기

```js
const products = [
  { name: 'a', price: 1000},
  { name: 'b', price: 1100},
  { name: 'c', price: 1010},
  { name: 'd', price: 1001},
]
```

```js
const under1030 = []
for (const p of products) {
  if (p.price < 1030) under1030.push(p)
}
console.log(...under1030)

const under1100 = []
for (const p of products) {
  if (p.price < 1100) under1100.push(p)
}
console.log(...under1100)
```

리팩토링을 해보면
```js
const filter = () => {
  const res = []
  for (const p of producs) {
     if (p.price < 1030) under1030.push(p)
  }
  return res
}
```

```js
const filter = (iter) => {
  const res = []
  for (const a of iter) {
     if (a.price < 1030) res.push(a)
  }
  return res
}
```

```js
const filter = (f, iter) => {
  const res = []
  for (const a of iter) {
     if (f(a)) res.push(a)
  }
  return res
}
```

사용해보면

```js
console.log(...filter(p => p.price < 1030, products))
```

다음과 같이 활용도 가능하다
```js
console.log(...filter(n => n % 2, function* () {
  yield 1
  yield 2
  yield 3
  yield 4
  yield 5
}()))
```

### filter 함수는 내부의 값에 대한 다형성은 보조함수를 통해서 높이고, 외부의 값에 대한 다형성은 Iterable Protocol을 따르게 함으로써 다형성을 높였다.