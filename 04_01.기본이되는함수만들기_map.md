## 기본이 되는 함수 만들기, 다형성이란?

---

## map: 수집하기

---

```js
const products = [
  { name: "a", price: 1000 },
  { name: "b", price: 1100 },
  { name: "c", price: 1010 },
  { name: "d", price: 1001 },
];
```

#### for 문을 이용하여 name 출력

```js
let names = [];
for (const p of products) {
  names.push(p.name);
}

console.log(names);
```

FP 에서는 `console.log(names)` 처럼 직접 외부 세상에 변화를 일으키는 것이 아니라, 함수가 인자와 리턴값으로 소통하는 것을 권장함

```js
const map = () => {
  let names = [];
  for (const p of products) {
    names.push(p.name);
  }
  return names;
};
```

#### 인자 추상화

```js
const map = (iter) => {
  let res = [];
  for (const p of iter) {
    res.push(p.name);
  }
  return res;
};
```

#### 수집 행위의 추상화

```js
const map = (f, iter) => {
  let res = [];
  for (const a of iter) {
    res.push(f(a));
  }
  return res;
};
```

사용법

```js
console.log(map((p) => p.name, products));
```

### Iterable Protocol을 활용한 map의 다형성

```js
console.log(document.querySelectorAll("*"));
```

배열 처럼 보이는 자과값에 native method map을 적용해 보자

```js
console.log(document.querySelectorAll("*").map((el) => el.nodeName));
```

동작하지 않는다.

앞에서 만든 map을 활용해 보자

```js
console.log(map((el) => el.nodeName, document.querySelectorAll("*")));
```

정상 동작하는 이유는 `document.querySelectorAll('*')`의 결과가 즉, `NodeList` 가 Iterable Protocol을 따르고 있어서 이다

따라서 다음도 가능하다.

```js
function* gen() {
  yield 2;
  yield 3;
  yield 4;
}

console.log(map((v) => v * v, gen()));
```

### native Array.prototype.map 보다 우리가 만든 map이 다형성이 높다.

prototype 기반으로 혹은 class 기반으로 만들어진, 카테고리 안에 있는 값만 사용 가능한 메소드 보다 유연하고 다형성이 높다.

```js
const m = new Map();
m.set("a", 10);
m.set("b", 20);

console.log(map(([k, v]) => [k, v * 2], m));
console.log(new Map(map(([k, v]) => [k, v * 2], m)));
```
